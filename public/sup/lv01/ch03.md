# Программирование игровой логики

## Введение

Если вы ничего не знаете о программировании на Javascript (на котором основан TypeScript), вам стоит прочитать какой-нибудь учебник, чтобы иметь небольшое представление об этом (например [этот](https://learn.javascript.ru/)). Не волнуйтесь, программирование это не так сложно, как вы могли себе представлять, в основном вам нужно научится решать реальные логические проблемы, главное не спешить и постепенно усвоить основные понятия. Вам может показаться, что это работает медленно и абстрактно даже для простых вещей. Но постепенно практикуясь, вы будете решать задачи быстрее и правильнее. (Часто, разочарование приходит, когда мы пытаемся выполнить задачу, к которой не готовы.)

Однако, вы можете продолжить урок и попытаться понять основы, просто копируя код в Superpowers. Повторяя и практикуясь, изучая и тестируя, делая ошибки и исправляя их (это мы называем отладкой, фундаментальное понятие в программировании, где ошибки нужно не избегать, а понимать) медленно, но уверенно вы будете делать удивительные успехи.

## Программирование поведение ракеток

Теперь мы можем начать программировать логику нашей игры, начнем реализовывать движение ракеток.

В папке GameScripts _(Скрипты Игры)_, откроем скрипт Paddles _(Ракетки)_. Вы увидите стандартный скрипт, удаляем все и вместо этого пишем следующий шаблон:

``` ts
class Paddle1Behavior extends Sup.Behavior {

  update() {

  }
}

class Paddle2Behavior extends Sup.Behavior {

  update() {

  }
}

Sup.registerBehavior(Paddle1Behavior);
Sup.registerBehavior(Paddle2Behavior);
```

Мы будем работать в первом классе _(Class)_ `Paddle1Behavior`, второй класс `Paddle2Behavior` будет почти таким же.

Определим переменные для класса, `pad` _(ракетка)_ будет привязана в телу в нашей сцене и number _(число)_ `speed` _(скорость)_. Пишем под строкой класса:

``` ts
class Paddle1Behavior extends Sup.Behavior {
    // присоединяем тело ракетки к переменной, которая будет часто использоваться в скрипте
    pad = this.actor.arcadeBody2D;
    // устанавливаем скорость ракетки
    speed : number = 0.1;
[...]
```

Мы будем использовать условие `if` _(если)_ и команду `Sup.Input`, которая играет важную роль в Superpowers, так как позволяет получить пользовательский ввод, чтобы игрок мог управлять игрой используя мышь, клавиатуру, геймпад или свои пальцы на мобильных устройствах.

Нам нужна возможность приказать телу спрайта двигаться, если нажата клавиша на клавиатуре. Для этого используется команда `setVelocityY` (потому что мы будем двигать ракетку только по оси **Y**).

Также нужно проверять не вышла ли ракетка за экран, для этого нужно ограничить максимум и минимум, до которых ракетка может передвигаться вверх и вниз. Чтобы это реализовать, нужно отслеживать Y положение ракетки и добавить в условия возможность перемещать ракетку только тогда, когда она ниже максимального и выше минимального значения Y.

В метод `update` _(обновление)_ добавим следующий скрипт:

``` ts
[...]
update() {

    // получаем Y позицию ракетки в переменную
    let y : number = this.actor.getY() ;

    // если нажата клавиша W и y < максимума, направленная скорость тела
    // устанавливается на значение переменной скорости
    if(Sup.Input.isKeyDown("W") && y < 2.35){
      this.pad.setVelocityY(this.speed);
    }
    // если нажата клавиша S и y > минимума, направленная скорость тела
    // устанавливается на отрицательное значение скорости
    else if(Sup.Input.isKeyDown("S") && y > -2.35){
      this.pad.setVelocityY(-this.speed);
    }
    // в других случаях скорость тела устанавливается на 0
    else{
      this.pad.setVelocityY(0);
    }

  }
[…]
```

Чтобы проверить скрипт, нужно прикрепить его к Актеру в Сцене. Для ракетки первого игрока создаем новый компонент **Behavior** _(Поведение)_ и выбираем класс `Paddle1Behavior`.

![behavior.png](https://github.com/mseyne/superpowers-tutorials/raw/master/1SuperPong/img/behavior.png)

Теперь запустим нашу программу и видим, что ракетка двигается вверх и вниз при нажатии клавиш W и S.

Для второй ракетки, скопируем этот код в класс `Paddle2Behavior`, но в `Sup.Input.isKeyDown` заменим
W и S на 'UP' и 'DOWN'.

Также как и с первой ракеткой, прикрепим скрипт к ракетке второго игрока
(new component>Behavior) _(создать компонент>Поведение)_, но выберем класс `Paddle2Behavior`.

## Программирование поведения мяча

Начнем программировать перемещение мяча в ассета скрипт Ball из папки
GameScripts. Этот Скрипт будет больше, чем скрипт ракеток, потому что мы будем прописывать столкновения и систему очков внутри одного класса.

Удалим из стандартного шаблона метод `start`, в этой игре он не понадобится. Начальный скрипт должен выглядеть так:

``` ts
class BallBehavior extends Sup.Behavior {

  update() {

  }
}
Sup.registerBehavior(BallBehavior);
```
Поскольку у мяча будет ускорение, добавим скорость по умолчанию в виде константы, на которую мы будем ссылаться. вынесем константу из основного класса, для этой игры это не имеет значения, но в других играх, такую константу мы сможем использовать в других классах игры. Это хорошая практика, к которой стоит привыкнуть.

``` ts
const BALLSPEED : number = 0.05 ;
class BallBehavior extends Sup.Behavior {
[…]
```

Теперь добавим переменные в классе BallBehavior, одна для скорости мяча, которая будет увеличиваться начиная от нашей константы `BALLSPEED`, один `array` _(массив)_ содержащий счет для `player1` и `player2`. И две переменные, которые будут положительными или отрицательными и задавать направление движения мяча. Например, если мяч движется вверх и ударяется об верхний край стола, переменная примет противоположное значение, говоря нам,
что мяч начал двигаться в противоположном направлении.


``` ts
[…]
class BallBehavior extends Sup.Behavior {
    // переменная скорости
    speed : number = BALLSPEED;
    // Присоединяем тело актера к переменной
    ball = this.actor.arcadeBody2D;
    // Массив с score[0] для player 1 и score[1] для player 2
    score = [0, 0];
    // устанавливаем положительные или отрицательные
    // переменные направления для x и y
    dx : number = 1; dy : number = 1;
[…]
```

Напишем несколько условий для разных случаев:

1. Если мяч касается верхней или нижней стороны стола, он меняет направление по оси Y и продолжает двигаться в туже сторону по оси X. Просто проверяем состояние и если это истинно, меняем переменную `dy`.

2. Если мяч сталкивается с ракетками, он получает небольшое ускорение и начинает двигаться в противоположном направлении по оси X, а направление оси Y остается прежним (мяч должен столкнутся с левой или правой стороной ракетки). Используем метод `Sup.ArcadePhysics2D.collides`, чтобы проверить столкнулось ли Физическое Тело мяча с ракетками. И еще проверка стороны столкновения мяча с помощью метода `getTouches`.

3. Если мяч коснется левой или правой стороны стола (когда ракетка не ловит его), увеличивается счет игрока, который забил этот гол (мы сделаем это чуть позже). Мяч возвращается в центр и возвращается к стандартной скорости.

Хорошо, теперь напишем поведение мяча внутри цикла метода `update`.

``` ts
[…]
  update() {

    // получаем позицию мяча по x и y

    let x : number  = this.actor.getX(); let y : number  = this.actor.getY();

    // меняем направление мяча по y, если он достиг верхней или нижней стороны

    if(y > 2.85 || y < -2.85){
      this.dy = this.dy * -1;
    }

    // Проверяем, есть ли столкновение между мячом и ракеткой

    if(Sup.ArcadePhysics2D.collides(this.ball, Sup.ArcadePhysics2D.getAllBodies())){

      /* Если есть столкновение, проверяем мячь столкнулся
      с ракеткой левой/правой (меняем направление x) или
      верхней/нижней стороной (направление y),
      и немного увеличиваем скорость мяча. */

      if(this.ball.getTouches().right || this.ball.getTouches().left){
        this.dx = this.dx * -1;
        this.speed += 0.01
        }
      else {
        this.dy = this.dy * -1;
        }

      }

    /* Проверяем, прошел ли мячь мимо ракетки и вышел ли за
    пределы экрана (с левой или правой стороны стола).
    Если да, перемещаем мяч в центр, меняем направление
    по оси X и возвращаем скорости начальное значение. */

    if(x > 4 || x < -4){
       this.ball.warpPosition(0, 0);
       this.dx = this.dx * -1;
       this.speed = BALLSPEED;
       }

    // устанавливаем направленную скорость мяча (скорость*направление)
    // для осей Y и X (мяч всегда должен быть в движении)

    this.ball.setVelocity(this.speed*this.dx, this.speed*this.dy);

  }
[…]
```

Чтобы увидеть скрипт в действии, мы должны, как ранее, прикрепить его к Актеру Ball в сцене Game. (new component>behavior, class = BallBehavior)

Теперь игра должна работать.

## Система очков

Теперь добавим простую систему очков. Нам нужно, чтобы, когда противник пропускает мячь, счет игрока увеличивается на один.

Для этого, добавим два условия в конце класса BallBehavior, одно для случая когда мяч коснулся стороны первого игрока и один для стороны второго игрока.

Используем метод `textRenderer`, чтобы изменять отображение счета, к нему прикрепим метод `getActor('Player1').getChild('Score')` для очков первого игрока и `getActor('Player2').getChild('Score')` для очков второго.

``` ts
[...]
    //Меняем счет в зависимости от того, с какой стороны прошел мяч по оси X
    if(x > 4){
      ++this.score[0];
      Sup.getActor("Player1").getChild("Score").textRenderer.setText(this.score[0]);
    }

    if(x < -4){
      ++this.score[1];
      Sup.getActor("Player2").getChild("Score").textRenderer.setText(this.score[1]);
    }

    // устанавливаем направленную скорость мяча (скорость*направление)
    // для осей Y и X (мячь всегда должен быть в движении)
    this.ball.setVelocity(this.speed*this.dx, this.speed*this.dy);
  }
}
Sup.registerBehavior(BallBehavior);
```

Мы закончили игровую логику. Нужно сделать еще пару вещей, чтобы выпустить игру, но уже сейчас в нее можно играть.
